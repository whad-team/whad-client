#!/usr/bin/env python3

# Written by Sultan Qasim Khan
# Copyright (c) 2024, NCC Group plc
# Released as open source under GPLv3

import os
import urllib.request

# Overly simplistic YAML parser for Bluetooth Assigned Numbers
# I made this to avoid adding a dependency
# This is not a general purpose parser
def decode_yaml(d: bytes):
    lines = d.split(b'\n')
    records = {}

    cur_record = None
    cur_name = None
    cur_subrecord = None

    for line in lines:
        if line.startswith(b'#') or len(line) == 0:
            continue
        elif line.startswith(b' '):
            ls = line.strip()
            if ls.startswith(b'-'):
                if cur_subrecord:
                    cur_record.append(cur_subrecord)
                cur_subrecord = {}
                ls = ls[2:]
            key, val = ls.split(b':')
            key_s = str(key.rstrip(), encoding='utf-8')
            val_s = str(val.lstrip(), encoding='utf-8')
            if val_s.startswith("0x"):
                val_s = int(val_s, 16)
            elif val_s.startswith("'"):
                val_s = val_s[1:-1]
            cur_subrecord[key_s] = val_s
        else:
            if cur_name:
                records[cur_name] = cur_record
            cur_name = str(line.strip()[:-1], encoding='utf-8')
            cur_record = []

    if cur_record:
        if cur_subrecord:
            cur_record.append(cur_subrecord)
        records[cur_name] = cur_record

    return records

def fetch_assigned_numbers(fname):
    url = "https://bitbucket.org/bluetooth-SIG/public/raw/HEAD/assigned_numbers/" + fname
    with urllib.request.urlopen(url) as f:
        d = f.read()
    return d

def pretty_print_dict(d, key_digits=4):
    lines = ["{"]
    for k in d:
        lines.append(f"    0x{k:0{key_digits}X}: {repr(d[k])},")
    lines.append("}")
    return "\n".join(lines)

def main():
    print("Fetching company identifiers")
    comp_ids_yaml = fetch_assigned_numbers("company_identifiers/company_identifiers.yaml")
    company_identifiers = {}
    for c in decode_yaml(comp_ids_yaml)["company_identifiers"]:
        company_identifiers[c["value"]] = c["name"]

    print("Fetching AD types")
    ad_types_yaml = fetch_assigned_numbers("core/ad_types.yaml")
    ad_types = {}
    for t in decode_yaml(ad_types_yaml)["ad_types"]:
        ad_types[t["value"]] = t["name"]

    print("Fetching service UUIDs")
    service_uuids_yaml = fetch_assigned_numbers("uuids/service_uuids.yaml")
    # Custom service UUIDs not assigned by Bluetooth SIG can be defined here
    service_uuids16 = {
        0xFFFA: 'ASTM Remote ID'
    }
    for u in decode_yaml(service_uuids_yaml)["uuids"]:
        service_uuids16[u["uuid"]] = u["name"]

    constants_file_path = os.path.join(os.path.dirname(__file__), "constants.py")
    print("Writing", constants_file_path)
    with open(constants_file_path, 'w') as f:
        f.write("# Auto generated by constants_generator.py\n\n")
        f.write("company_identifiers = ")
        f.write(pretty_print_dict(company_identifiers))
        f.write("\n\n")
        f.write("ad_types = ")
        f.write(pretty_print_dict(ad_types, 2))
        f.write("\n\n")
        f.write("service_uuids16 = ")
        f.write(pretty_print_dict(service_uuids16))
        f.write("\n")

if __name__ == "__main__":
    main()
